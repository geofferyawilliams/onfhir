server {
  host = 0.0.0.0
  port = 8080
  base-uri = fhir
  ssl {
    #Path to the keystore
    keystore = null
    #Password of the keystore
    password = null
  }
}

fhir {
  #Whether to initialize from configuration files, or normal execution of server
  initialize = true
  #Version of the FHIR standard to be supported (i.e. "stu3" or "r4")
  version = "r4"
  # Root URL for Server Access (this can be different from server.properties due to deployment alternatives)
  root-url = "http://127.0.0.1:8080/fhir"
  # Root URL for FHIR Infrastructure Resource definitions (Conformance, StructureDefinition, etc), if null this will be same with root-url
  definitions-url = "http://onfhir.io"

  #Validation alternatives
  # base => Validation against base HL7 FHIR resources and profiles
  # profile => Validation against all provided profiles
  # none => Disable resource validation
  validation = "profile"

  # Search mechanism handling alternatives
  # handling=lenient => Ignores unknown/unsupported parameters and perform search
  # handling=strict => Returns an error if unknown/unsupported parameters are used
  search-handling = "handling=lenient"


  # Should convert binary ccd resource to fhir resource
  # Only supported for C-CDA R2.1 to DSTU2
  cda-to-fhir = false

  initialization {
    //Path to definitions.zip that includes the base definitions
    base-definitions-path = null

    #Conformance Path
    conformance-path = "/fhir/conf/conformance.xml"

    #Profiles Path
    profiles-path = "/fhir/conf/profiles"

    #Parameters Path
    parameters-path = null

    #CompartmentDefinition Path
    compartments-path = null

    #Valuse Sets path
    valuesets-path = null
	
	  codesystems-path = null

	  index-conf-path = "/fhir/conf/db-index-conf.json"

    #Operation Definitions path
    operations-path = null
  }

  default {
    #Default preference to return in HTTP responsense. Can be either minimal or representation
    return-preference = representation
    #Default page count when returning results from history and search operations
    page-count = 20
    #Default value for [CapabilityStatement|Conformance].rest.resource.versioning when not present
    versioning = "versioned"
    #Default value for [CapabilityStatement|Conformance].rest.resource.readHistory when not present
    read-history = false
    #Default value for [CapabilityStatement|Conformance].rest.resource.updateCreate when not present
    update-create = true
    #Default value for [CapabilityStatement|Conformance].rest.resource.conditionalCreate when not present
    conditional-create = false
    #Default value for [CapabilityStatement|Conformance].rest.resource.conditionalUpdate when not present
    conditional-update = false
    #Default value for [CapabilityStatement|Conformance].rest.resource.conditionalDelete when not present
    conditional-delete = "not-supported"
  }

  authorization {
    # Authorization mechanism applied in this repo e.g. none -> No Authorization, smart-on-fhir -> Smart on FHIR compliant authorization
    method = "none"
    # How the access token will be resolved e.g. introspection --> By OAuth2 introspection, jwt --> Direct JWT evaluation, jwt-introspection --> JWT with introspection
    token-resolution = "introspection"
    # If false, we assume fhir-server is registered to the Authorization Server manually but then we need registration data from configuration (see resource-server-metadata-path)
    # If true (Not-implemented yet), we will register fhir-server during set-up
    authz-server-dynamic-registration = false
    # Path for the metadata file, if not given the default metadata will be used
    resource-server-metadata-path = null
    # Path for the JWKS file (including signing keys) for our resource server (required if authentication method for introspection requires key based authentication)
    resource-server-jwks-path = null
    # If none, we assume the metadata of Authorization Server will be given by configuration (see  authz-server-metadata-path)
    # Other options are;  oauth2 -> OAuth2 Discovery , oidc -> OpenID Connect discovery
    authz-server-discovery = "none"
    # Full discovery service URL e.g. https://authorize-dstu2.smarthealthit.org/.well-known/openid-configuration (required if 'authz-server-discovery' is not none)
    # authz-server-discovery-url = ?
    # Path for the metadata of Authorization Server (required if 'authz-server-discovery' is none) See OAuth2 Discovery for required metadata attributes
    # authz-server-metadata-path = ?
    #authz-server-metadata-path = "D:/Codes/onfhir/repository/fhir-repository/src/main/resources/authorization-server-metadata.json"

    # Caching preferences for access tokens (both introspection, or jwt) accessToken -> Resolved Authz Context (scopes, etc)
    # Max capacity of cache (# of tokens)
    token-caching-max-capacity = 1000
    # Initial capacity of cache (# of tokens)
    token-caching-initial-capacity = 100
    # Time to live for each token (in minutes)
    token-caching-time-to-live = 30
    # Idle time for each token to remove it from the cache (in minutes)
    token-caching-time-to-idle = 10
  }

  auditing {
    # Remote Audit Repository address (FHIR base url),
    # 'local' -> means we will store them locally
    # 'none' -> means no auditing
    # 'remote' -> means we send the audits to external audit server
    repository = "none"
    # Base url of Audit Repository (if remote)
    # repository-url = "http://127.0.0.1:8082/audit-server"
    # Is Audit Repository secure? (if remote)
    # is-secure = false
  }
}

akka {
  stdout-loglevel = "OFF"
  loglevel = "OFF"
  #loggers = [akka.event.slf4j.Slf4jLogger]
  #loglevel = debug
  actor {
    #debug {
    #  receive = off
    #  lifecycle = off
    #}
    deployment {
      "/**" {
        dispatcher = "akka.actor.onfhir-blocking-dispatcher"
      }
    }
    onfhir-blocking-dispatcher {
      type = Dispatcher
      executor = "thread-pool-executor"
      thread-pool-executor {
        fixed-pool-size = 32
      }
      throughput = 1
    }
  }
}

akka.http {
  server {
    server-header = OnFhir.io Repository
    parsing{
      uri-parsing-mode = relaxed
    }
    request-timeout = 30 s
    idle-timeout = 60 s
    remote-address-header = on
  }
}

kafka {
  host = localhost
  port = 9092
  topic = raw.fhir
  client.id = fhir
  enabled = false
}

mongodb {
  host= [${?DB_HOST}]
  #port=27017
  db=onfhir
  sharding=false
  transaction=false
  #Uncomment below if MongoDB requires user authentication
  #authdb="admin"
  #username="admin"
  #password="5rdc"
}
